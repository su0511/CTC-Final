<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Hesse's Mirror</title>
<style>
html, body {
margin: 0;
padding: 0;
background: #0d0d0d;
color: #e0e0e0;
font-family: 'EB Garamond', serif;
overflow: hidden;
cursor: none; 
}

canvas {
display: block;
position: absolute;
z-index: 0;
}

.text-layer {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 2;
}

.fragment {
position: absolute;
font-size: 1rem;
padding: 0.8rem 1.2rem;
background: rgba(255, 255, 255, 0.05);
border: 1px solid rgba(255, 255, 255, 0.15);
backdrop-filter: blur(4px);
opacity: 0;
transition: all 0.3s ease;
white-space: normal; /* Allow text to wrap */
width: auto; /* Adjust width to content */
max-width: 300px; /* Set a maximum width if needed */
}

.fragment.visible {
opacity: 1;
}
</style>
</head>
<body>
<div class="text-layer"></div>

<script src="https://cdn.jsdelivr.net/npm/p5@1.4.2/lib/p5.min.js"></script>
<script>
let shards = [];
const texts = [
"Where was the Self to be found?", // Siddhartha's question
"Was not Atman in him alone?", // Siddhartha's thought
"Who was it who taught him?", // Siddhartha's question
"He had begun to suspect that his worthy father and his other teachers, the wise Brahmins, had already imparted to him the bulk and total of their wisdom...", // Siddhartha's realization with line breaks
"Why had he to hear and learn so much, if he knew this one and only thing: that Atman dwells within him?", // Siddhartha's question with line break
"Slowly, the breathing of the calmed <br> man deepened." // Just an observation for variety
];


let dotX;
let dotY;
let easing = 0.08; // Adjust for more or less delay
let stuckInShard = null; // Index of the shard the dot is stuck in
let touchEdgeCount = 0;
const exitTouchThreshold = 2;
let dotSpeedX = 0;
let dotSpeedY = 0;
const friction = 0.95;
let currentShardIndex = -1; // Track the shard the dot is currently inside

let stars = [];
const numStars = 200;

function setup() {
createCanvas(windowWidth, windowHeight);
noFill();
stroke(255, 30);
let textLayer = document.querySelector('.text-layer');
for (let i = 0; i < texts.length; i++) {
let shard = {
x: random(width),
y: random(height),
baseY: 0, // for floating
r: random(60, 80),
entered: false,
offset: random(1000),
fragment: document.createElement('div')
};
shard.fragment.classList.add('fragment');
shard.fragment.innerHTML = texts[i]; // Use innerHTML for line breaks
textLayer.appendChild(shard.fragment);
shards.push(shard);
}

// Initialize dot position
dotX = width / 2;
dotY = height / 2;

// Initialize stars
for (let i = 0; i < numStars; i++) {
stars.push({
x: random(width),
y: random(height),
size: random(1, 3),
brightness: random(100, 255),
alpha: random(50, 200),
twinkleSpeed: random(0.01, 0.05),
twinkleOffset: random(TWO_PI)
});
}
}

function draw() {
clear();
background(0); // Set canvas background to black for stars

// Draw twinkling stars
for (let star of stars) {
const twinkle = map(sin(frameCount * star.twinkleSpeed + star.twinkleOffset), -1, 1, 0.5, 1);
fill(255, star.alpha * twinkle);
noStroke();
ellipse(star.x, star.y, star.size * twinkle, star.size * twinkle);
}

let t = millis() / 1000;

for (let i = 0; i < shards.length; i++) {
const s = shards[i];
s.baseY = 15 * sin(t * 1.5 + s.offset);
strokeWeight(s.entered ? 2 : 0.5);
fill(s.entered ? color(255, 20) : color(0, 0, 0, 0));
stroke(255, 80);

ellipse(s.x, s.y + s.baseY, s.r);

// Update fragment position and visibility
const fragment = s.fragment;
fragment.classList.toggle('visible', s.entered);

if (s.entered) {
let fragmentX = s.x + 20;
let fragmentY = s.y + s.baseY - 10;

const fragmentWidth = fragment.offsetWidth;
const fragmentHeight = fragment.offsetHeight;

if (fragmentX + fragmentWidth > width) {
fragmentX = s.x - fragmentWidth - 20;
}
if (fragmentY + fragmentHeight > height) {
fragmentY = s.y + s.baseY - fragmentHeight + 10;
}
if (fragmentY < 0) {
fragmentY = s.y + s.baseY + 20;
}

fragment.style.left = fragmentX + 'px';
fragment.style.top = fragmentY + 'px';
}
}

// Control the dot's movement based on stuck state
if (stuckInShard !== null) {
dotX += dotSpeedX;
dotY += dotSpeedY;
dotSpeedX *= friction;
dotSpeedY *= friction;

const s = shards[stuckInShard];
const d = dist(dotX, dotY, s.x, s.y + s.baseY);

// Keep dot inside the shard
if (d > s.r / 2) {
const angle = atan2(dotY - (s.y + s.baseY), dotX - s.x);
dotX = s.x + cos(angle) * s.r / 2;
dotY = (s.y + s.baseY) + sin(angle) * s.r / 2;
touchEdgeCount++;
dotSpeedX *= -0.5; // Bounce back slightly
dotSpeedY *= -0.5;
} else if (d < s.r * 0.4) {
touchEdgeCount = 0; // Reset if moving back towards center
}

if (touchEdgeCount >= exitTouchThreshold && !mouseIsPressed) {
shards[stuckInShard].entered = false;
stuckInShard = null;
touchEdgeCount = 0;
dotSpeedX = 0;
dotSpeedY = 0;
}
} else {
// Easing for the white dot when not stuck
let targetX = mouseX;
let dx = targetX - dotX;
dotX += dx * easing;

let targetY = mouseY;
let dy = targetY - dotY;
dotY += dy * easing;
dotSpeedX = 0;
dotSpeedY = 0;
}

// Draw the white dot as cursor
fill(255);
noStroke();
ellipse(dotX, dotY, 8, 8);

// Check if the dot has entered a shard to get stuck
if (stuckInShard === null) {
for (let i = 0; i < shards.length; i++) {
const s = shards[i];
const d = dist(dotX, dotY, s.x, s.y + s.baseY);
if (d < s.r / 2) {
stuckInShard = i;
shards[i].entered = true;
touchEdgeCount = 0;
dotSpeedX = 0;
dotSpeedY = 0;
break;
} else {
shards[i].entered = false; // Ensure 'entered' is false when outside
}
}
} else if (!mouseIsPressed) {
stuckInShard = null; // Release stuck state if mouse is released
touchEdgeCount = 0;
}
}

function mouseDragged() {
if (stuckInShard !== null) {
dotSpeedX += (mouseX - pmouseX) * 0.1;
dotSpeedY += (mouseY - pmouseY) * 0.1;
}
}

function windowResized() {
resizeCanvas(windowWidth, windowHeight);
dotX = width / 2;
dotY = height / 2;
shards.forEach(s => {
s.x = random(width);
s.y = random(height);
});
}
</script>
</body>
</html>